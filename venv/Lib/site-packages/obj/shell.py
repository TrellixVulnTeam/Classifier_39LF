""" shell related commands. """

import atexit
import logging
import logging.handlers
import optparse
import os
import os.path
import readline
import rlcompleter
import stat
import sys
import termios
import time
import threading

import obj
import obj.utils

defaults = {
            "all": False,
            "args": [],
            "background": False,
            "channel": "#obj",
            "exclude": "",
            "history": False,
            "level": "error",
            "modules": "",
            "nick": "obj",
            "options": "",
            "password": "",
            "server": "",
            "shell": False,
            "verbose": False,
            "write": "",
            "workdir": "",
            "yes": "",
}

opts = [
    ('-a', '', 'store_true', False, 'all', 'load all modules'),
    ('-b', '', 'store_true', False, 'background', 'enable daemon mode.'),
    ('-c', '', "string", '', 'channel', 'channel to join.'),
    ('-d', '', 'string', '', 'workdir', 'set working directory.'),
    ('-g', '', 'store_true', False, 'history', 'enable history file.'),
    ('-l', '', 'string', 'error', 'level', 'loglevel.'),
    ('-m', '', 'string', '', 'modules', 'modules to load.'),
    ('-n', '', 'string', '', 'nick', 'nickname to use when joining a channel'),
    ('-o', '', "string", '', 'options', 'character options to use.'),
    ('-p', '', "string", '', 'password', 'provide password to login with.'),
    ('-s', '', 'string', '', 'server', 'connect server channel nick.'),
    ('-v', '', 'store_true', False, 'verbose', 'enable verbose mode.'),
    ('-w', '', 'store_true', False, 'write', 'use written configuration.'),
    ('-x', '', 'string', '', 'exclude', 'exclude module'),
    ('-y', '', 'store_true', False, 'yes', 'use yes as default answer.'),
    ('-z', '', "store_true", False, 'shell', 'enable shell.'),
    ('', '--debug', "store_true", False, 'debug', 'enable debug mode.'),
    ('', '--logdir', "string", "" , 'logdir', 'logging directory'),
    ('', '--name', "string", "", 'name', 'name of the program.'),
    ('', '--port', "store_true", False, 'port', 'provide port number to connect to.'),
    ('', '--resume', "store_true", False, 'resume', 'resume from filedescriptor.'),
]

resume = {}

class Completer(rlcompleter.Completer):

    """ tab completer. """
 
    def __init__(self, commands=None):
        super().__init__()
        self.commands = commands or []
        self.matches = []

    def complete(self, text, state):
        """ complete text. """
        if state == 0:
            if text: 
                self.matches = [s for s in self.commands if s and s.startswith(text)]
            else:
                self.matches = self.commands[:]
        try:
            return self.matches[state]
        except IndexError:
            return None

class DumpHandler(logging.StreamHandler):

    """ print nothing logging handler. """

    propagate = False

    def emit(self, record):
        pass

class Shell(obj.handler.Handler):

    """ a basic handler to use as a shell. """

    def __init__(self):
        super().__init__()
        self._prompted = threading.Event()

    def announce(self, txt):
        """ annouce text on the shell. """
        if self.verbose:
            self.raw(txt)

    def raw(self, txt):
        """ display raw text. """
        if self.verbose:
            sys.stdout.write(txt)
            sys.stdout.flush()
        
    def say(self, orig, channel, txt, type=None):
        """ prepend newline character to the displayed txt. """
        self.raw(str(txt) + "\n")

class Console(Shell):

    """ Shell with prompt. """

    def dispatch(self, event):
        """ dispatch an event and signal _prompted. """
        e = super().dispatch(event)
        e.wait()
        self._prompted.set()
        return e

    def get_event(self):
        """ return an event from a typed string. """
        e = obj.event.Event()
        self._prompted.wait()
        e.txt = input("> ")
        self._prompted.clear()
        e.orig = repr(self)
        e.origin = "root@shell"
        return e

    def initialize(self, mods):
        """ register modules with the console. """
        res = []
        thrs = []
        exclude = obj.cfg.exclude.split(",")
        for m in mods:
            if not m or m in exclude:
                continue
            try:
                thrs = self.walk(m, True)
                for thr in thrs:
                    thr.join()
            except Exception as ex:
                logging.error(obj.get_exception())

    def prompt(self):
        """ show prompt. """
        if self.verbose and not self._prompted.isSet():
            self.prompted.set()
            self.raw("> ")

    def start(self):
        """ start the console. """
        super().start()
        self._prompted.set()

def check_permissions(path, dirmask=0o700, filemask=0o600):
    """ set permissions of a directory. """
    uid = os.getuid()
    gid = os.getgid()
    try:
        stats = os.stat(path)
    except FileNotFoundError:
        return
    except OSError:
        dname = os.path.dirname(path)
        stats = os.stat(dname)
    if stats.st_uid != uid:
        os.chown(path, uid, gid)
    if os.path.isfile(path):
        mask = filemask
    else:
        mask = dirmask
    mode = oct(stat.S_IMODE(stats.st_mode))
    if mode != oct(mask):
        os.chmod(path, mask)

def close_history():
    """ close history file. """
    if not obj.cfg.history:
        return
    try:
        histfile = os.path.abspath(os.path.join(obj.cfg.logdir, "history"))
        readline.write_history_file(histfile)
    except:
        pass

def daemon():
    """ run in background mode. """
    pid = os.fork()
    if pid != 0:
        reset()
        os._exit(0)
    os.setsid()
    os.umask(0)
    si = open("/dev/null", 'r')
    so = open("/dev/null", 'a+')
    se = open("/dev/null", 'a+')
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())
 
def enable_history():
    """ enable history. """
    histfile = os.path.abspath(os.path.join(obj.cfg.logdir, "history"))
    if os.path.exists(histfile):
        readline.read_history_file(histfile)
    atexit.register(close_history)

def get_completer():
    """ return the current completer. """
    return readline.get_completer()

def get_shell():
    """ return a shell. """
    console = Console()
    console.verbose = not obj.cfg.verbose
    console.initialize(obj.cfg.modules.split(","))
    console.start()
    return console

def ld(*args):
    """ return a filename in the logdir. """
    return os.path.abspath(os.path.join(obj.cfg.logdir, *args))

def level(loglevel, logdir="", logfile="obj.log", nostream=False):
    """ initialize logsystem and set loglevel. """
    assert obj.cfg.logdir
    logfile = os.path.join(obj.cfg.logdir, logfile)
    if not os.path.exists(logfile):
        obj.cdir(logfile)
    datefmt = '%H:%M:%S'
    format_time = "%(asctime)-8s %(message)-70s"
    format_plain = "%(message)-0s"
    loglevel = loglevel.upper()
    logger = logging.getLogger("")
    if logger.handlers:
        for handler in logger.handlers:
            logger.removeHandler(handler)
    if logger.handlers:
        for handler in logger.handlers:
            logger.removeHandler(handler)
    logger.setLevel(loglevel)
    formatter = logging.Formatter(format_plain, datefmt)
    if nostream:
        dhandler = DumpHandler()
        dhandler.propagate = False
        dhandler.setLevel(loglevel)
        logger.addHandler(dhandler)
    else:
        handler = logging.StreamHandler()
        handler.propagate = False
        handler.setFormatter(formatter)
        handler.setLevel(loglevel)
        logger.addHandler(handler)
    formatter2 = logging.Formatter(format_time, datefmt)
    filehandler = logging.handlers.TimedRotatingFileHandler(logfile, 'midnight')
    filehandler.propagate = False
    filehandler.setFormatter(formatter2)
    filehandler.setLevel(loglevel)
    logger.addHandler(filehandler)
    return logger

def make_opts(options, usage, version):
    """ create command line options to be parsed. """
    parser = optparse.OptionParser(usage=usage, version=version)
    for opt in options:
        if not opt:
            continue
        otype, deft, dest, htype = opt[2:]
        if "store" in otype:
            parser.add_option(opt[0], opt[1], action=otype, default=deft, dest=dest, help=htype)
        else:
            parser.add_option(opt[0], opt[1], type=otype, default=deft, dest=dest, help=htype)
    return parser.parse_args()

def parse_cli(name="obj", options=None, usage="", version="", wd=""):
    """ parse commandline options. """
    ver = "%s #%s" % (name.upper(), version or obj.__version__)
    opt, arguments = make_opts(options or opts, usage, ver)
    cfg = obj.Cfg()
    cfg.update(vars(opt))
    cfg.name = name
    cfg.workdir = cfg.workdir or wd or obj.hd(".%s" % obj.cfg.name)
    cfg.logdir = os.path.join(cfg.workdir, "logs")
    cfg.storedir = os.path.join(cfg.workdir, "store")
    cfg.version = version or obj.__version__
    cfg.args = arguments
    obj.cfg.update(cfg)
    level(cfg.level)
    logging.warning("%s started (%s) at %s" % (name.upper(), cfg.level, time.ctime(time.time())))
    logging.warning("workdir %s" % cfg.workdir)
    logging.warning("level %s" % cfg.level)
    if cfg.history:
        enable_history()
    return cfg
        
def reset():
    """ reset terminal. """
    close_history()
    if "old" in resume:
        termreset(resume["fd"], resume["old"])

def set_completer(commands):
    """ set completer to complete list of commands. """
    completer = Completer(commands)
    readline.set_completer(completer.complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))

def start(name, modules=[], version=obj.__version__, wd="", shell=False):
    """ start the program. """
    try:
        termsave()
        cfg = parse_cli(name, version=version, wd=wd)
        if modules:
            cfg.modules += "," + ",".join(modules)
        cfg.shell = shell or cfg.shell
        obj.cfg.update(cfg)
        writepid()
        if cfg.background:
            logging.error("switching to daemon mode.")
            daemon()
        tail(cfg)
    except KeyboardInterrupt:
        print("")
    except Exception as ex:
        logging.error(obj.get_exception())
    reset()
    os._exit(0)

def tail(cfg):
    if cfg.args:
        e = obj.cmd(" ".join(cfg.args))
        for txt in e._result:
            print(txt)
        return e
    elif cfg.shell:
        shell = get_shell()
        shell.wait()

def termsave():
    resume["fd"] = sys.stdin.fileno()
    resume["old"] = termsetup(sys.stdin.fileno())
    atexit.register(reset)

def termreset(fd, old):
    termios.tcsetattr(fd, termios.TCSADRAIN, old)

def termsetup(fd):
    old = termios.tcgetattr(fd)
    return old

def touch(fname):
    try:
        fd = os.open(fname, os.O_RDONLY | os.O_CREAT)
        os.close(fd)
    except TypeError:
        pass

def writepid():
    path = os.path.join(obj.cfg.logdir, "pidfile")
    f = open(path, 'w')
    f.write(str(os.getpid()))
    f.flush()
    f.close()
