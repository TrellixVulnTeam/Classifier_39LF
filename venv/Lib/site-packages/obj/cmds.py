""" basic commands. """

import json
import obj
import os
import time
import threading

from obj.utils import days, elapsed, short

starttime = time.time()

def ed(event):
    if not event.selector:
        event.reply("ed <selector> <setter>")
        return
    o = obj.last(event.match)
    if not o:
        return
    if not event.setter:
        event.reply(o)
        return
    obj.edit(o, event.setter)
    fn = o.save() 
    event.reply("ok 1")

def find(event):
    if len(event.args) < 1:
        event.reply("find <%s>" % "|".join(obj.classes.keys()))
        return
    elif len(event.args) == 1:
        o = obj.last(event.match)
        if o and not event.selector:
            for a in o.keys():
                if a not in event.selector:
                    event.selector[a] = None
                if a not in event.dkeys:
                    event.dkeys.append(a)
    stime = time.time()
    nr = -1
    for p, o in obj.store.find(event.match, event.selector, event.index, event.delta):
        txt = ""
        if "k" in event.options:
            event.reply("|".join(o.keys()))
            return
        if "d" in event.options:
            event.reply(str(o))
            continue
        full = False
        if "f" in event.options:
            full = True
        nr += 1
        if event.dkeys:
            txt = "%s %s" % (event.index or nr, obj.format(o, event.dkeys, full))
        else:
            txt = "%s %s" % (event.index or nr, obj.format(o, full=full))
        if "t" in event.options:
            txt += " " + days(p)
        if txt:
            event.reply(txt)

def log(event):
    o = obj.Log()
    o.txt = event.rest
    o.save()
    event.reply("ok 1")

def rm(event):
    if not event.args:
        event.reply("rm <selector>")
        return
    st = time.time()
    nr = -1
    for o in obj.find(event.match, event.selector, event.index, event.delta):
        nr += 1
        o._deleted = True
        o.save()
    event.reply("ok %s %s" % (nr+1, elapsed(time.time()-st)))

def show(event):
    try:
        cmd, *args = event.args
    except ValueError:
        event.reply("cfg|cmds|help|mods|threads|types|uptime|version")
        return
    if cmd == "cfg":
        event.reply(obj.cfg)
    elif cmd == "cmds":
        event.reply("|".join(sorted(obj.names.keys())))
    elif cmd == "mods":
        event.reply("|".join(sorted(obj.modnames.values())))
    elif cmd == "help":
        res = ""
        for key, val in obj.aliases.items():
            res += "%s (%s) " % (key, val.split()[-1])
        if res:
            event.reply(res)
    elif cmd == "threads":
        psformat = "%-8s %-60s"
        result = []
        try:
            getnr = int(event.args[1])
        except (ValueError, IndexError):
            getnr = None
        for thr in sorted(threading.enumerate(), key=lambda x: x.getName()):
            d = vars(thr)
            o = obj.Object()
            o.update(d)
            if o.get("sleep", None):
                up = o.sleep - int(time.time() - o.state.latest)
            else:
                up = int(time.time() - starttime)
            result.append((up, thr.getName(), o))
        nr = -1
        for up, thrname, o in sorted(result, key=lambda x: x[0]):
            nr += 1
            if getnr is not None and getnr == nr:
                event.reply(o)
                return
            res = "%s %s" % (nr, psformat % (elapsed(up), thrname[:30]))
            event.reply(res)
    elif cmd == "types":
        event.reply("|".join(obj.types))
    elif cmd == "version":
        event.reply("%s %s" % (obj.cfg.name.upper(), obj.cfg.version))
    elif cmd == "uptime":
        event.reply(elapsed(time.time() - obj.starttime))

def stop(event):
    if not event.args:
        event.reply("stop <threadname>")
        return
    name = event.args[0]
    obj.kill(name)
    event.reply("kill %s" % name)

def undel(event):
    if not event.args:
        event.reply("undel <selector>")
        return
    st = time.time()
    nr = -1
    for o in obj.find(event.match, event.selector, event.index, event.delta, showdel=True):
        nr += 1
        o._deleted = False
        o.save()
    event.reply("ok %s %s" % (nr+1, elapsed(time.time()-st)))
